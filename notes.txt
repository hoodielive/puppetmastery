IaaC

Resource -> what do you want? 
    user = xyz 
    uid = 5001
    pass = xxx 

    -> $user (object) -> [provider] -> [dsl (domain specific language)] 

    puppet/chef will do the translation into -> 

    user (resource) provider (who will take care of it i.e. ruby)


Declarative Approach  -> leverage and control the 'state' of our infrastructure 

Revision Control 

Recreate the Infrastructure out of code repo (code base) -> simplies migration and modularity (even disaster recovery)

Absolute 'consistency'

Puppet Automation 
    -> End State (always start with end state in mind) 
    
Layers 

    Web Server (NGINX) 
        - install 'Package'
        - create configuration 'File' 
        - start 'Service'
        - create 'Web Page'

        i.e ** Puppet resource[Package, File, Service, File]

        - Think about the process and configure from the 'end' of the 'state' you wish you implement the change

            Package [ state = installed ] 
            Config File [ state = created ] 
            Service [ state = started ] 
            Web Page [ state = created ] 
        
        **further** 
            Package 
                state = installed 
                    version = latest 

            Config File 
                state = created 
                ownership/permissions 
                    mode = '0644'
                    owner = 'root' 

            Service 
                state = started 
                enabled 

            Web Page [File] 
                state = created 
                source 
                ownership/permissions 

                * these are properties * 
                
    -> all these together is what you call a Resource 
    
    to write these, you have to write them to a file called a manifest (init.pp) 
        manifest, a collection of resources written for a certain object 
            with puppets dsl 


 Nodes is where you apply your modules (apps) 

    DSL -> Resources, Manifests, Modules 

    Load Balancers 

    Databases
#

######## Resources ########
- puppet looks at your infrastructure as a collection of entities: 
	packages
	cronjob
	file
	network interfaces
	service 
	directory
	user
	- > these entities are described as 'resources'
	- > resources are statements of configuration policy which are written using PUPPET'S DSL (Domain Specific Language) 

- puppet then translates these 'resources' into 'providers' which are platform specific procedures 
	(yum, apt, zypper) 

	So for example: If you want to install nginx - that would get translated to commands specific to that platform:
		apt for ubuntu 
		yum to redhat/centos
		zypper to opensuse

type:
	user { 'devops': 
		uid  	=> '5001',
		gid     => '5001',
		home    => '/home/devops',
		shell	=> '/bin/bash',
		ensure  => present,
	}

	To know what resource types are  available - go to the puppet reference or get core types cheat sheet 


#### MANIFESTS ####
- manifests are files which contain collection of resources 
- written to achieve a specific objective 
- have .pp extention (puppet dsl) 
- resources in a manifest can be applied in any order

base.pp
	Lets create a recipe base.pp with following resource specifications

	Create user
		- deploy 

	Install Packages 
		- tree
		- git
		- ntp
		- wget
		- unzip

	Start service 
		- ntp 
	
	Remove user 
		- dojo

	Add file /etc/motd with content "Property of XYZ"

#### MODULES ####

- modules are packages with manifests and supporting files 

- have 1:1 mapping with applications 

- let you create a library of reusable code 

- check out puppet forge: http://forge.puppet.com 

Anatomy of a Module: 
Manifests: 
    - files 
    - templates
    - data
    - spec
    - examples
    - metadata.json 
    - README.md


study - puppetlabs/puppet-ntp for a good example of modules 
